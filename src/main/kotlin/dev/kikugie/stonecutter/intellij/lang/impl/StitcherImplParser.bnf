{
    parserClass="dev.kikugie.stonecutter.intellij.lang.StitcherParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Stitcher"
    psiPackage="dev.kikugie.stonecutter.intellij.lang.psi"
    psiImplPackage="dev.kikugie.stonecutter.intellij.lang.impl"

    elementTypeHolderClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenTypes"
    elementTypeClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenType"
    tokenTypeClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenType"

    implements("replacement")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"
    implements("condition")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"
    implements("swap")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"

    implements("condition")="dev.kikugie.stonecutter.intellij.lang.access.ConditionDefinition"

    implements("expression")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition"
    implements("expression")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition"
    implements("assignment")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition.Member"
    implements("constant")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition.Member"

    implements("string_version")="dev.kikugie.stonecutter.intellij.lang.access.VersionDefinition"
    implements("semantic_version")="dev.kikugie.stonecutter.intellij.lang.access.VersionDefinition"

    implements("predicate")="dev.kikugie.stonecutter.intellij.lang.access.PredicateDefinition"
}

definition ::= COND_MARKER condition
    | SWAP_MARKER swap
    | REPL_MARKER replacement

replacement ::= LITERAL { elementType = "REPLACEMENT_ID" }
swap ::= CLOSER | (swap_id OPENER?)
/* TODO: Require sugar to follow this notation (in a non-cancer way):
condition ::= SUGAR_IF expression OPENER?
    | CLOSER (
        (SUGAR_ELSE SUGAR_IF | SUGAR_ELIF)? expression OPENER?
        | SUGAR_ELSE OPENER?
      )
 */
condition ::= CLOSER? SUGAR* expression? OPENER?

swap_id ::= LITERAL { elementType = "SWAP_ID" }

expression ::= binary_expression
    | simple_expression

private simple_expression ::= unary_expression
    | group_expression
    | assignment
    | constant

private binary_expression ::= simple_expression BINARY expression
private unary_expression ::= UNARY expression
private group_expression ::= LEFT_BRACE expression RIGHT_BRACE

assignment ::= dependency ASSIGN predicate_list
    | explicit_predicate_list

private any_predicate ::= implicit_predicate | predicate { extends = predicate }
private implicit_predicate ::= string_version | semantic_version { extends = predicate }
predicate ::= COMPARATOR (string_version | semantic_version) | semantic_version

private explicit_predicate_list ::= predicate any_predicate* { extends = predicate_list }
private predicate_list ::= any_predicate+

constant ::= LITERAL { elementType = "CONSTANT" }
dependency ::= LITERAL { elementType = "DEPENDENCY" }

string_version ::= LITERAL
semantic_version ::= version_core (DASH pre_release)? (PLUS build_metadata)?

version_core ::= NUMERIC (DOT NUMERIC)*
pre_release ::= IDENTIFIER (DOT IDENTIFIER)*
build_metadata ::= IDENTIFIER (DOT IDENTIFIER)*