{
    parserClass="dev.kikugie.stonecutter.intellij.lang.StitcherParser"
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Stitcher"
    psiPackage="dev.kikugie.stonecutter.intellij.lang.psi"
    psiImplPackage="dev.kikugie.stonecutter.intellij.lang.impl"

    elementTypeHolderClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenTypes"
    elementTypeClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenType"
    tokenTypeClass="dev.kikugie.stonecutter.intellij.lang.StitcherTokenType"

    implements("replacement")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"
    implements("condition")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"
    implements("swap")="dev.kikugie.stonecutter.intellij.lang.access.ScopeDefinition"

    implements("condition")="dev.kikugie.stonecutter.intellij.lang.access.ConditionDefinition"

    implements("expression")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition"
    implements("expression")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition"
    implements("assignment")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition.Member"
    implements("constant")="dev.kikugie.stonecutter.intellij.lang.access.ExpressionDefinition.Member"

    implements("string_version")="dev.kikugie.stonecutter.intellij.lang.access.VersionDefinition"
    implements("semantic_version")="dev.kikugie.stonecutter.intellij.lang.access.VersionDefinition"

    implements("predicate")="dev.kikugie.stonecutter.intellij.lang.access.PredicateDefinition"

    tokens=["COMMENT"]
}

definition ::= COND_MARKER condition
    | SWAP_MARKER swap
    | REPL_MARKER replacement

replacement ::= IDENTIFIER { elementType = "REPLACEMENT_ID" }
swap ::= CLOSER | (swap_key swap_arg* scope_opener?)

swap_key ::= IDENTIFIER { elementType = "SWAP_ID" }
swap_arg ::= IDENTIFIER | QUOTED { elementType = "STRING" }

condition ::= SUGAR_IF expression scope_opener?
    | CLOSER (
        (SUGAR_ELSE SUGAR_IF | SUGAR_ELIF | SUGAR_ELSE)? expression scope_opener?
        | SUGAR_ELSE scope_opener?
        |
      )

scope_opener ::= OPENER | WORD

expression ::= binary_expression
    | simple_expression

private simple_expression ::= unary_expression
    | group_expression
    | assignment
    | constant

private binary_expression ::= simple_expression BINARY expression
private unary_expression ::= UNARY expression
private group_expression ::= LEFT_BRACE expression RIGHT_BRACE

assignment ::= dependency ASSIGN predicate_list
    | explicit_predicate_list

private any_predicate ::= implicit_predicate | predicate { extends = predicate }
private implicit_predicate ::= string_version | semantic_version { extends = predicate }
predicate ::= COMPARATOR (string_version | semantic_version) | semantic_version

private explicit_predicate_list ::= predicate any_predicate* { extends = predicate_list }
private predicate_list ::= any_predicate+

constant ::= IDENTIFIER { elementType = "CONSTANT_ID" }
dependency ::= IDENTIFIER { elementType = "DEPENDENCY_ID" }

string_version ::= IDENTIFIER
semantic_version ::= version_core (DASH pre_release)? (PLUS build_metadata)?

version_core ::= NUMERIC (DOT NUMERIC)*
pre_release ::= metadata (DOT metadata)*
build_metadata ::= metadata (DOT metadata)*

metadata ::= NUMERIC | LITERAL { elementType = "VERSION" }